#include <iostream>
using namespace std;

long long dp[104][14];
int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin >> n;
	for (int i = 1; i <= 9; ++i) 
		dp[1][i] = 1;
	for (int i = 2; i <= n; ++i) {
		dp[i][0] = dp[i - 1][1];
		dp[i][9] = dp[i - 1][8];
		for (int j = 1; j <= 8; ++j)
			dp[i][j] = (dp[i - 1][j + 1] + dp[i - 1][j - 1]) % 1'000'000'000;
	}
	long long ans = 0;
	for (int j = 0; j < 10; ++j)
		ans += dp[n][j];
	cout << ans % 1'000'000'000;
}
// dp[1]: 1 2 3 4 5 6 7 8 9 -> 9개 // 0또는 9의 개수 9개
// dp[i][j]
//
// int num[10] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1}; -> 9
// int num[10] = {1, 1, 2, 2, 2, 2, 2, 2, 2, 1}; -> 17
// int num[10] = {1, 3, 3, 4, 4, 4, 4, 4, 3, 2}; -> 32
// int num[10] = {3, 4, 7, 7, 8, 8, 8, 7, 6, 3}; -> 61
// 
// 
//
// num[0] = num[1];
// 
// 0의개수 0
// 1의 개수 1
// 9의 개수 1
//
// 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 // 17개
// dp[2]: 17개
// 0의 개수 1
// 1의 개수 1
// 9의 개수 1
//
// dp[2] 일 때 2의 개수가 2개이니까 
//
// 0의 개수 1
// 1의 개수 1 + 1
// 9의 개수 2
// dp[3] = 30 + 2
//
// dp[4] 
// 0의 개수 
//
// dp[3]: 
//
// 10 12
//
// dp[i]: 자리수가 i일 때, 가능한 계단수
//
// dp[1] = 9
//
// 0으로 끝나는거 0개 1로 끝나는거 1개 9로 끝나는거 1개
// // 1 2 3 4 5 6 7 8 9  -> 2 * 8 + 1
//
// 10 
// 12 21 23 32 34 89 98 -> 17개(9로 끝나는게 1개가 있으니까)
//
//
// dp[2]
// 0으로 끝나는거 몇개?
// 1로 끝나는거 
//
// 101 
//
//
//
//
//
//
//
//
//
//
// dp[2] = 17
// // 0 1 2 3 4 5 6 7 8 9
//   (1) 
//   +1 
// dp[3] = 0 1 2 3 4 5 6 7 8 9 - > 2 * 8 + 2
//
//
